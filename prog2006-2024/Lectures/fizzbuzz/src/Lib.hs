module Lib
    ( fizzBuzz
    , fizzBuzz'
    , fizzBuzzFun
    , convert
    , swap3
    ) where

import Data.List (intercalate)

-- Code generated by co-pilot
-- It is not good.
-- fizzBuzz_shitty :: Int -> String
-- fizzBuzz_shitty n
--     | n `mod` 3 == 0 && n `mod` 5 == 0 = "FizzBuzz"
--     | n `mod` 3 == 0 = "Fizz"
--     | n `mod` 5 == 0 = "Buzz"
--     | otherwise = show n

-- This code uses case with tuple, and it is OK.
-- We are not repeating ourselves, and the code is 
-- both readable and easily maintainable.
-- We are not benefitting though from the fact that the action
-- for fizz is composable with the action for buzz.
-- Nevertheless, for languages with pattern matching,
-- this is possibly the most idiomatic way of solving it.
--
-- >>> fizzBuzz 3
-- "Fizz"
-- >>> fizzBuzz 5
-- "Buzz"
-- >>> fizzBuzz 15
-- "FizzBuzz"
-- >>> fizzBuzz 7
-- "7"
fizzBuzz :: Int -> String
fizzBuzz n = case (n `mod` 3, n `mod` 5) of
    (0, 0) -> "FizzBuzz"
    (0, _) -> "Fizz"
    (_, 0) -> "Buzz"
    _ -> show n

-- Code with WHERE -- OK
-- We are not repeating ourselves
-- but we are not benefiting from the fact that both actions
-- for fizz and buzz are independent and composable. 
--
-- >>> fizzBuzz' 3
-- "Fizz"
-- >>> fizzBuzz' 5
-- "Buzz"
-- >>> fizzBuzz' 15
-- "FizzBuzz"
-- >>> fizzBuzz' 7
-- "7"
fizzBuzz' :: Int -> String
fizzBuzz' n
    | isFizz && isBuzz = "FizzBuzz"
    | isFizz = "Fizz"
    | isBuzz = "Buzz"
    | otherwise = show n
    where
        isFizz = n `mod` 3 == 0
        isBuzz = n `mod` 5 == 0


-- Functions -- OK, with guards
--
fizz :: Int -> String
fizz n
    | n `mod` 3 == 0 = "Fizz"
    | otherwise = ""

buzz :: Int -> String
buzz n
    | n `mod` 5 == 0 = "Buzz"
    | otherwise = ""

-- | Composable functions -- OK
-- We are not repeating ourselves, but
-- we are not able to avoid the final IF expression!
-- Can we do it WITHOUT IF?
--
-- >>> fizzBuzzFun 3
-- "Fizz"
-- >>> fizzBuzzFun 5
-- "Buzz"
-- >>> fizzBuzzFun 15
-- "FizzBuzz"
-- >>> fizzBuzzFun 7
-- "7"
fizzBuzzFun :: Int -> String
fizzBuzzFun n = if null (fizz n ++ buzz n) 
    then show n 
    else fizz n ++ buzz n





-- | Given a list of three numbers, return a String
-- with those numbers comma separated values.
-- We will generalise the solution to arbitrary length lists.
-- We could use pattern matching to guard to only
-- accept lists of length 3, but we will not do that here.
-- It is better practice to use the type system or
-- validation module to ensure the input is correct.
-- 
-- >>> convert [1, 2, 3]
-- "1, 2, 3"
convert :: [Int] -> String
-- convert3 [x, y, z] = show x ++ ", " 
--     ++ show y ++ ", " 
--     ++ show z
-- using compasition of functions and it is generic
convert = intercalate ", " . map show


-- Given a list of 3 numbers, swap the first and last one.
-- We will generalise the solution to arbitrary length lists.
-- We could use pattern matching to guard to only 
-- accept lists of length 3, but we will not do that here.
-- It is better practice to use the type system or
-- validation module to ensure the input is correct.
-- 
-- >>> swap3 [1, 2, 3]
-- [3, 2, 1]
--
-- >>> swap3 [1, 2, 3, 4]
-- [4, 2, 3, 1]
swap3 :: [a] -> [a]
swap3 list = undefined
-- copilot generated solutions are not always good.
-- In fact, they are ofte quite shitty, because most programmers
-- and most examples are shitty. 
-- take the first element, take the last element,
-- swap them, and put the rest in the middle